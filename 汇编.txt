#  计算机原理 —— 汇编



## 语言

**什么是机器语言？**

```shell
# 主流为电子计算机
状态：0 和 1
# 最早的程序员，穿孔卡带
加 0100 0000
减 0100 1000
乘 0100 1000 0100 1000
除 0100 1000 1100 1000
```

复杂的机器语言，简化为助记符！——— **汇编语言**

```shell
加 INC <-编译器->
减 DEC
乘 MUL
除 DIV
```

离程序的本质：隔阂！汇编一般用于底层的编写，单片机

**C语言**

```shel
加 INC A+B
减 DEC A-B
乘 MUL A*B
除 DIV A/B
```

暴力破解



## 进制

**什么是二进制？**

学习进制的障碍？10进制！8进制 2进制 1进制	

思想：每一种进制都是完美的，都有自己的计算方式



**进制？** ——   **查数**

1进制：一进一，结绳记事

2进制：计算机	

8进制： 八进一，8个符号组成：0 1 2 3 4 5 6 7 

10进制：十进一

16进制：十六进一



**进制只是一组符号！！！**

> 测试

```shell
# 一进制 1~20
1
1 1
1 1 1
1 1 1 1
.......

# 二进制 1~20
0   1
10  11
100 101
110 111
.......

# 三进制 1~20
0   1   2
10  11  12
20  21  22
100 101 102
110 111 112
120 121 122
.......

# 八进制 1~20
0  1  2  3  4  5  6  7
10 11 12 13 14 15 16 17
20 21 22 23 24 25 26 27
.......
```



### 进制如何运算

```shell
# 八进制的计算	0  1  2  3  4  5  6  7
2+3=5
2*3=6
4+5=11
4*5=24

# 运算的本质就是查数
```



八进制的乘法表

| 1*1=1  | 1*2=2  | 1*3=3  | 1*4=4  | 1*5=5  | 1*6=6  | 1*7=7 |
| ------ | ------ | ------ | ------ | ------ | ------ | ----- |
| 2*2=4  | 2*3=6  | 2*4=10 | 2*5=12 | 2*6=14 | 2*7=16 |       |
| 3*3=11 | 3*4=14 | 3*5=17 | 3*6=22 | 3*7=25 |        |       |
| 4*4=20 | 4*5=24 | 4*6=30 | 4*7=34 |        |        |       |
| 5*5=31 | 5*6=36 | 5*7=43 |        |        |        |       |
| 6*6=44 | 6*7=52 |        |        |        |        |       |
| 7*7=61 |        |        |        |        |        |       |

```shell
# 运算的本质就是查数

277 
333 +
-----
632

  276
   54 *
--------
 1370
 1466 +
--------
20250 
 
 # 减法的本质就是加法
 # 除法的本质就是除数乘以哪个数最接近结果即可
```

**结论：**无论是什么进制，本身都是有一套完美的运算体系的，我们都可以通过列表的方式将他计算出来



## 二进制

计算机使用二进制  0 1	物理极限：摩尔定律	追求语言的极限	并发语言	软操作

**量子计算机：**（传道）

可以实现量子计算的机器

传统计算机通过集成电路计算：硅晶片

量子计算机的单位：昆比特（量子比特）量子的两态来表示	

光子：正交偏振方向

磁场：电子的自旋方向

量子计算机！提高计算机的计算力

量子比特、量子叠加态、量子纠纷、量子并行原理

```shell
二进制 0 1

0 1 10 11 100 101 110 111 1000 1001 1010 1011 1100 1101 1110 1111
```

二进制能否简写？十六进制！

```shell
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 
```

为什么要学习理解二进制？

寄存器、内存、位！底层的每一个位都是有含义的	——	汇编入门理解的基础

汇编高级：了解程序的深层	操作系统的内核



## 数据宽度

计算机：内存！给数据增加数据宽度

```shell
bit		[]
Byte	[] [] [] [] [] [] [] []
Word	16位
DWord	32位 0000 0000 0000 0000 0000 0000 0000 0000
```

C	C++	Java	都需要定义数据的类型，计算机底层需要我们给这些数据定义宽度

位		0	1

字节	0 ~ 0xFF

字		0 ~ 0xFFFF

双字	0 ~ 0xFFFFFFF

在计算机中，每一个数据都需要给它定义类型和宽度，在内存中的宽度



## 有符号和无符号数

数据都是有宽度的，每个数据代表什么意思？

```shell
0 1 0 1 0 1 0 1
```

**规则**：二进制解码规则



**无符号数规则**

```shell
1 0 0 1  1 0 1 0 十六进制：0x9A 十进制：154
```



**有符号数规则**

最高位是符号位：1(负数)	0(正数)

```shell
1 0 0 1  1 0 1 0 如何转换？
```



## 原码反码补码

**编码规则**

有符号数的编码规则：

原码：最高符号位，对齐它的位进行本身绝对值

反码：

- 正数：反码和原码相同
- 负数：符号位一定是1，其余位对原码取反

补码：

- 正数：补码和原码相同
- 负数：符号位一定是1，反码+1

> 测试

```shell
# 8位

# 如果是正数,都是一样
1 
#原码 0 0 0 0  0 0 0 1
#反码 0 0 0 0  0 0 0 1
#补码 0 0 0 0  0 0 0 1

# 如果是负数
-1
#原码 1 0 0 0  0 0 0 1
#反码 1 1 1 1  1 1 1 0
#补码 1 1 1 1  1 1 1 1

-7
#原码 1 0 0 0  0 1 1 1
#反码 1 1 1 1  1 0 0 0
#补码 1 1 1 1  1 0 0 1

# 二进制的标志
2	10
4 	100
8	1000
16	1 0000
```



## 位运算

计算机现在可以存储所有的数字(整数，浮点数，字符)

**位运算**

2*8 最高效的计算方式

很多底层的调试器，需要通过位来判断CPU的状态



**与运算 (and &)**

两个都为1，结果为1

```shell
1011 0001
1101 1000
----&---- 
1001 0000
```



**或运算 (or |)**

只要有1，结果为1

```shell
1011 0001
1101 1000
----|---- 
1111 1001
```



**异或运算 (xor ^)**

不相同，则结果为1

```shell
1011 0001
1101 1000
----^---- 
0110 1001
```



**非运算 (单目运算符 not ~)**

0就是1，1就是0，取反

```shell
1101 1000
--- ~ --- 
0010 0111 
```



**位运算 (移动位)**

通用位运算来实现加减乘除

```shell
0000 0001 1
0000 0010 2
0000 0100 4
0000 1000 8
0001 0000 16
```



**左移 (shi <<)**

```shell
0000 0001	@ 所有二进制全部左移若干位，高位就丢弃了，低位补0
0000 0010 
```



**右移 (shr >>**)

```shell
0000 0001	@ 所有二进制全部右移若干位，低位就丢弃了，高位补0，1（符号位决定）
0000 0000

int a = 10;
prinf("%d\n",a>>2);
```



### 位运算计算

计算机只认识0和1

基本数学是建立在加减乘除**（！加法！）**

**4+5？**

```shell
# 计算机是怎么操作的
0000 0100
0000 0101
----+---- （加法，计算机是不会直接加的）
0000 1001

# 计算机的的实现原理

# 第一步：异或：如果不考虑进位，异或就可以直接出结果
0000 0100
0000 0101
--------------
0000 0001

# 第二步：与运算（判断进位，如果与运算结果为0，则没有进位）
0000 0100
0000 0101
--------------
0000 0100

# 第三步：将与运算的结果，左移一位：0000 1000 （进位的结果）

# 第四步：异或
0000 0001
0000 1000
--------------
0000 1001

# 第五步：与运算（判断进位，如果与运算结果为0，则没有进位）
0000 0001
0000 1000
--------------
0000 0000

# 所以最终结果为：与运算为0的结果的上一个异或运算



```

**4-5？**

```shell
# 计算机是怎么操作的
0000 0100
0000 0101  补码1111 1011
--------- （减法，计算机是不会直接加的）
1111 1111

# 计算机的的实现原理

# 第一步：异或：如果不考虑进位，异或就可以直接出结果
0000 0100
1111 1011
--------------
1111 1111 

# 第二步：与运算（判断进位，如果与运算结果为0，则没有进位）
0000 0100
1111 1011
--------------
0000 0000

# 所以最终结果为：与运算为0的结果的上一个异或运算
1111 1111	FF	-1
```

**乘：**x * y，本质就是加法，就是y个x相加

**除：**x / y，本质就是减法，就是x能减去多少个y

**计算机只会做加法！**

机器语言就是位运算，都是电路来实现的，是计算机最底层的本质

通过机器语言来实现加法计算器，设计电路



## 汇编语言环境说明

通过指令来代替我们的二进制编码！

ADD指令转换为二进制操作

通过汇编指令给计算机发一些操作，然后让计算机执行

编译器的发展，大佬都是用最原始的IDE

在学习汇编之前，大家需要先掌握环境的配置

1. Vc6（程序到汇编的理解）

2. OD	

3. 抓包工具	

4. 加密解密工具

   

**学汇编不是为了学代码**

- 理解程序的本质
- 学习32位汇编 《汇编语言》
- 汇编入门：了解汇编和程序的对应关系



## 通用寄存器

寄存器：

存储数据：CPU > 内存 > 硬盘

32位 CPU	8	16	32

64位 CPU	8	16	32	64



**通用寄存器**	可以存储任意东西

```shell
# 32位的通用寄存器只有8个
```

存值范围：0 ~ FFFF FFFF

对于二进制来说，直接修改值



**计算机如何向寄存器存值**

- mov指令

- ```shell
  mov 存的地址，存的数
  mov 存的地址1，存的地址2
  ```

- 可以将数字写入到寄存器，也可以将寄存器中的值写入到寄存器

计算器：计算力！



不同的寄存器

```shell
         FFFF    FF
32位		16位		8位
EAX	     AX	     AL  
ECX      CX      CL
EDX      DX      DL
EBX      BX      BL
ESP      SP      AH
ENP      NP      CH   
ESI      SI      DH
EDI      DI      BH
```

8位：

- L 低八位 
- H 高八位 



## 内存

寄存器很小不够用，所以说，数据要放到内存

每个应用程序进程都有4GB的内存空间（空头支票） 4GB --> 物理内存 -->  内存条

程序真正运行的时候，才会用到物理内存

1 B = 8 bit

1 KB = 1024 B

1 MB = 1024 KB

1 GB = 1024 MB

4G的内存，4096MB	=>	最终计算为位，就是这个可以存储的最大容量	=>	34,359,738,368 bit

计算机中内存地址很多，空间很大



**内存地址**

存一个数：占用的大小，数据宽度，存到哪里？

计算机中内存地址很多，空间很大，每个空间分配一个地址，名字

```shell
[0x00000000]

............

[0xFFFFFFFF]
```

这些给内存起的编号，就是内存地址。32位 8个 16进制的值



32位：寻址能力！4GB

FFFF FFFF + 1 = 1 0000 0000，最大的值

**位** 是怎么限制内存大小的

1 0000 0000 内存地址 * 8 = 位： 8 0000 0000

转换为10进制 / 8：4,294,967,296 字节

按照规则 / 1024，最终发现就是 4GB



64位，绰绰有余

FFFF FFFF FFFF FFFF + 1

所以每个内存地址都有一个编号	可以通过编号向里面存值



**内存如何存值？**

数据宽度：byte	word	dword	qword

地址的位置：0xFFFFFFFF

不是任意的地址都可以写东西的，只有申请过的内存地址才可以使用

```shell
汇编如何向内存中写值
mov 数据宽度 内存地址 1
mov byte / word / dword / qword	1

mov byte ptr ds:[0x19FF70],1

传递的值的大小，一定要和数据宽度（类型）相等
```



**内存有多种写法**

ds:[0x19FF70+4] 内存地址偏移

ds:[eax]

ds:[eax+4] 寄存器偏移

数组[]

ds:[reg+reg*(1,2,4,8)]